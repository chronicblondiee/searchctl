input {
  beats {
    port => "${BEATS_PORT:5044}"
  }
}

filter {
  grok {
    match => {
      "message" => [
        "%{IPORHOST:clientip} - %{DATA:remote_user} \[%{HTTPDATE:time_local}\] \"%{WORD:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}\" %{NUMBER:status:int} %{NUMBER:body_bytes_sent:int} \"%{DATA:referrer}\" \"%{DATA:agent}\" %{NUMBER:request_length:int} %{NUMBER:request_time:float} \[%{DATA:upstream_status}\] \[%{DATA:upstream_addr}\] \[%{NUMBER:upstream_response_time:float}\] %{DATA:namespace}/%{DATA:ingress}/%{DATA:service}/%{DATA:pod} %{DATA:host} %{IPORHOST:server_addr}:%{NUMBER:server_port:int}"
      ]
    }
    tag_on_failure => ["_grok_ingress_failure"]
  }

  mutate {
    rename => { "clientip" => "source.ip" }
  }

  useragent {
    source => "agent"
    target => "user_agent"
  }

  geoip {
    source => "source.ip"
    target => "geoip"
  }
}

output {
  elasticsearch {
    hosts => [ "${ES_HOSTS:https://localhost:9200}" ]
    user => "${ES_USERNAME:elastic}"
    password => "${ES_PASSWORD:changeme}"
    # api_key => "${ES_API_KEY}"
    data_stream => true
    data_stream_type => "logs"
    data_stream_dataset => "nginx.ingress"
    data_stream_namespace => "${DATA_STREAM_NAMESPACE:default}"
    ilm_enabled => false
    # cacert => "${ES_CACERT}"
  }
}
