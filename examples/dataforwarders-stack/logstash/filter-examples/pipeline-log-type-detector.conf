input {
  http {
    host => "${HTTP_HOST:0.0.0.0}"
    port => "${HTTP_PORT:8088}"
    additional_codecs => { "application/json" => "json" }
  }
}

filter {
  # Try Apache combined first
  grok {
    match => { "message" => ["%{COMBINEDAPACHELOG}"] }
    tag_on_failure => ["_not_apache"]
    add_tag => ["log_type:apache_access"]
  }

  # Nginx access
  if "_not_apache" in [tags] {
    grok {
      match => { "message" => ["%{IPORHOST:clientip} - %{DATA:ident} %{DATA:auth} \[%{HTTPDATE:nginx.access.time}\] \"%{WORD:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}\" %{NUMBER:response:int} %{NUMBER:bytes:int} \"%{DATA:referrer}\" \"%{DATA:agent}\""] }
      tag_on_failure => ["_not_nginx_access"]
      add_tag => ["log_type:nginx_access"]
    }
  }

  # Nginx ingress
  if "_not_apache" in [tags] and "_not_nginx_access" in [tags] {
    grok {
      match => { "message" => ["%{IPORHOST:clientip} - %{DATA:remote_user} \[%{HTTPDATE:time_local}\] \"%{WORD:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}\" %{NUMBER:status:int} %{NUMBER:body_bytes_sent:int} \"%{DATA:referrer}\" \"%{DATA:agent}\" %{NUMBER:request_length:int} %{NUMBER:request_time:float} \[%{DATA:upstream_status}\] \[%{DATA:upstream_addr}\] \[%{NUMBER:upstream_response_time:float}\] %{DATA:namespace}/%{DATA:ingress}/%{DATA:service}/%{DATA:pod} %{DATA:host} %{IPORHOST:server_addr}:%{NUMBER:server_port:int}"] }
      tag_on_failure => ["_not_nginx_ingress"]
      add_tag => ["log_type:nginx_ingress"]
    }
  }

  # Syslog auth
  if "_not_apache" in [tags] and "_not_nginx_access" in [tags] and "_not_nginx_ingress" in [tags] {
    grok {
      match => { "message" => ["%{SYSLOGTIMESTAMP:syslog_timestamp} %{HOSTNAME:host} sshd\[%{NUMBER:pid}\]: %{GREEDYDATA:sshd_message}",
                                  "%{SYSLOGTIMESTAMP:syslog_timestamp} %{HOSTNAME:host} sudo\[%{NUMBER:pid}\]: %{GREEDYDATA:sudo_message}"] }
      tag_on_failure => ["_not_syslog_auth"]
      add_tag => ["log_type:syslog_auth"]
    }

    grok {
      match => { "sshd_message" => ["Accepted %{WORD:ssh_method} for %{USERNAME:user.name} from %{IP:source.ip} port %{NUMBER:source.port:int}"] }
      tag_on_failure => ["_grok_sshd_parse_failure"]
    }

    date {
      match => ["syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss"]
    }
  }

  # K8s container (CRI)
  if "_not_apache" in [tags] and "_not_nginx_access" in [tags] and "_not_nginx_ingress" in [tags] and "_not_syslog_auth" in [tags] {
    dissect {
      mapping => { "message" => "%{ts->} %{stream} %{flags} %{log}" }
      add_tag => ["_cri_dissect"]
    }
    mutate {
      add_tag => ["log_type:k8s_container"]
    }
    date {
      match => ["ts", "ISO8601"]
      target => "@timestamp"
    }
    json {
      source => "log"
      target => ""
      skip_on_invalid_json => true
    }
    mutate {
      remove_field => ["flags", "host", "@version"]
    }
  }

  # Generic JSON app
  if "_not_apache" in [tags] and "_not_nginx_access" in [tags] and "_not_nginx_ingress" in [tags] and "_not_syslog_auth" in [tags] and "_cri_dissect" in [tags] {
    json {
      source => "message"
    }
    mutate {
      add_tag => ["log_type:json_app"]
      lowercase => ["level"]
      rename => { "host" => "host.name" }
    }
    date {
      match => ["@timestamp", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSZZ"]
      target => "@timestamp"
      timezone => "UTC"
    }
  }
}

output {
  elasticsearch {
    hosts => [ "${ES_HOSTS:https://localhost:9200}" ]
    user => "${ES_USERNAME:elastic}"
    password => "${ES_PASSWORD:changeme}"
    data_stream => true
    data_stream_type => "logs"
    data_stream_dataset => "auto.detected"
    data_stream_namespace => "${DATA_STREAM_NAMESPACE:default}"
    ilm_enabled => false
    # cacert => "${ES_CACERT}"
  }
}


